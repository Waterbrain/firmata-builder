/*!
 * Copyright 2015 Jeff Hoefs under the terms of the MIT license found at
 * https://github.com/firmata/firmata-builder/blob/master/LICENSE-MIT
 */

var allFeatures = require("../lib/features.js");

var featuresWithReporting = [];
var featuresWithUpdate = [];
var systemDependencies = Object.create(null);
var updateEnabled = false;
var reportingEnabled = false;

var analogInputEnabled = false;
var analogOutputEnabled = false;
var digitalInputEnabled = false;
var digitalOutputEnabled = false;
var servoEnabled = false;
var schedulerEnabled = false;

/**
 * Additional featurs should not be added to this function.
 * Ideally these comparisons will be eliminated at some point.
 * @private
 */
function setEnabledFeatures(selectedFeature) {
  switch (selectedFeature) {
  case "AnalogInputFirmata":
    analogInputEnabled = true;
    break;
  case "AnalogOutputFirmata":
    analogOutputEnabled = true;
    break;
  case "DigitalInputFirmata":
    digitalInputEnabled = true;
    break;
  case "DigitalOutputFirmata":
    digitalOutputEnabled = true;
    break;
  case "ServoFirmata":
    servoEnabled = true;
    break;
  case "FirmataScheduler":
    schedulerEnabled = true;
    break;
  }
}

/**
 * @module builder
 * Given a set of Firmata features and options, generates text for an Arduino
 * .ino file.
 */
var builder = {

  /**
   * @param {Object} data User selected features and options
   * @return {String} The text for the .ino file
   */
  build: function(data) {
    var outputText = "";

    this.filename = data.filename || "ConfiguredFirmata";
    this.connectionType = data.connectionType || {serial: {baud: 57600}};
    this.selectedFeatures = data.selectedFeatures;

    this.processFeatureSelection();

    outputText += this.createHeader();
    outputText += this.createIncludes();
    outputText += this.createPostDependencies();
    outputText += this.createSystemResetCallbackFn();
    outputText += this.createSetupFn();
    outputText += this.createLoopFn();

    return outputText;
  },

  /**
   * @private
   */
  processFeatureSelection: function() {
    var len = this.selectedFeatures.length;
    for (var i = 0; i < len; i++) {
      setEnabledFeatures(this.selectedFeatures[i]);
      var feature = allFeatures[this.selectedFeatures[i]];

      if (feature.reporting) {
        featuresWithReporting.push(feature);
      }
      if (feature.update) {
        featuresWithUpdate.push(feature);
      }
    }

    if (featuresWithReporting.length > 0) {
      reportingEnabled = true;
    }

    if (featuresWithUpdate.length > 0) {
      updateEnabled = true;
    }
  },

  /**
   * @private
   */
  createHeader: function() {
    var date = new Date();
    var header = "/*\n * " + this.filename + ".ino generated by FirmataBuilder\n";
    header += " * " + date.toString() + "\n */\n\n";
    return header;
  },

  /**
   * @private
   */
  createIncludes: function() {
    var includes = "#include <Firmata.h>\n\n";

    // Unfortunately because of the way the Arduino IDE compiles all class files in an imported
    // library's directory, Servo.h and Wire.h must be included even if ServoFirmata and I2CFirmata
    // are not selected or included.
    includes += "// Servo.h and Wire.h must be included or this sketch will not compile\n";
    includes += "#include <Servo.h>\n";
    includes += "#include <Wire.h>\n\n";

    for (var i = 0, len = this.selectedFeatures.length; i < len; i++) {
      var feature = allFeatures[this.selectedFeatures[i]];

      if (feature.systemDependencies) {
        for (var j = 0; j < feature.systemDependencies.length; j++) {
          var d = feature.systemDependencies[j];
          // prevent duplicate includes
          if (!systemDependencies[d.className]) {
            includes += "#include <" + d.path + d.className + ".h>\n";
            systemDependencies[d.className] = true;
          }
        }
      }

      includes += "#include <" + feature.path + feature.className + ".h>\n";
      includes += feature.className + " " + feature.instanceName + ";\n\n";
    }

    // always include FirmataExt
    includes += "#include <utility/FirmataExt.h>\n";
    includes += "FirmataExt firmataExt;\n\n";

    return includes;
  },

  /**
   * Dependencies that should be included after the initial set of included files.
   * @private
   */
  createPostDependencies: function() {
    var includes = "";
    if (analogOutputEnabled || servoEnabled) {
      includes += "#include <utility/AnalogWrite.h>\n\n";
    }
    if (reportingEnabled) {
      includes += "#include <utility/FirmataReporting.h>\n";
      includes += "FirmataReporting reporting;\n\n";
    }
    return includes;
  },

  /**
   * @private
   */
  createSystemResetCallbackFn: function() {
    var fn = "void systemResetCallback()\n";
    fn += "{\n";
    fn += "  for (byte i = 0; i < TOTAL_PINS; i++) {\n";
    fn += "    if (IS_PIN_ANALOG(i)) {\n";

    if (analogInputEnabled) {
      fn += "      Firmata.setPinMode(i, ANALOG);\n";
    }

    fn += "    } else if (IS_PIN_DIGITAL(i)) {\n";

    if (digitalOutputEnabled) {
      fn += "      Firmata.setPinMode(i, OUTPUT);\n";
    }

    fn += "    }\n";
    fn += "  }\n";

    fn += "  firmataExt.reset();\n";

    fn += "}\n\n";
    return fn;
  },

  /**
   * @private
   */
  createSetupFn: function() {
    var fn = "void setup()\n";
    fn += "{\n";

    fn += "  Firmata.setFirmwareVersion(FIRMATA_MAJOR_VERSION, FIRMATA_MINOR_VERSION);\n\n";

    if (analogOutputEnabled || servoEnabled) {
      fn += "  Firmata.attach(ANALOG_MESSAGE, analogWriteCallback);\n\n";
    }

    for (var i = 0, len = this.selectedFeatures.length; i < len; i++) {
      var feature = allFeatures[this.selectedFeatures[i]];
      fn += "  firmataExt.addFeature(" + feature.instanceName + ");\n";
    }

    if (reportingEnabled) {
      fn += "  firmataExt.addFeature(reporting);\n\n";
    }

    fn += "  Firmata.attach(SYSTEM_RESET, systemResetCallback);\n\n";

    if (this.connectionType.serial) {
      fn += "  Firmata.begin(" + this.connectionType.serial.baud + ");\n\n";
    }

    fn += "  systemResetCallback();\n";

    fn += "}\n\n";
    return fn;
  },

  /**
   * @private
   */
  createLoopFn: function() {
    var fn = "void loop()\n";
    fn += "{\n";

    if (digitalInputEnabled) {
      fn += "  digitalInput.report();\n\n";
    }

    fn += "  while(Firmata.available()) {\n";
    fn += "    Firmata.processInput();\n";

    if (schedulerEnabled) {
      fn += "    if (!Firmata.isParsingMessage()) {\n";
      fn += "      goto runtasks;\n";
      fn += "    }\n";
      fn += "  }\n"; // end while (if scheduler)
      fn += "  if (!Firmata.isParsingMessage()) {\n";
      fn += "runtasks: scheduler.runTasks();\n";
    }

    // if scheduler end if, else end while
    fn += "  }\n\n";

    if (reportingEnabled) {
      var numReporting = featuresWithReporting.length;
      fn += "  if (reporting.elapsed()) {\n";
      for (var i = 0; i < numReporting; i++) {
        fn += ("    " + featuresWithReporting[i].instanceName + ".report();\n");
      }
      fn += "  }\n\n";
    }

    if (updateEnabled) {
      var numUpdate = featuresWithUpdate.length;
      for (var k = 0; k < numUpdate; k++) {
        fn += ("  " + featuresWithUpdate[k].instanceName + ".update();\n");
      }
    }

    fn += "}\n";
    return fn;
  }

};

module.exports = builder;
