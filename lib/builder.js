/*!
 * Copyright 2015 Jeff Hoefs under the terms of the MIT license found at
 * https://github.com/firmata/firmata-builder/blob/master/LICENSE-MIT
 */

var allFeatures = require("../lib/features.js");

var filename;
var connectionType;

var featuresWithReporting = [];
var featuresWithUpdate = [];
var systemDependencies = Object.create(null);
var updateEnabled = false;
var reportingEnabled = false;

var analogInputEnabled = false;
var analogOutputEnabled = false;
var digitalInputEnabled = false;
var digitalOutputEnabled = false;
var servoEnabled = false;
var schedulerEnabled = false;

/**
 * Additional featurs should not be added to this function.
 * Ideally these comparisons will be eliminated at some point.
 * @private
 */
function setEnabledFeatures(selectedFeature) {
  switch (selectedFeature) {
  case "AnalogInputFirmata":
    analogInputEnabled = true;
    break;
  case "AnalogOutputFirmata":
    analogOutputEnabled = true;
    break;
  case "DigitalInputFirmata":
    digitalInputEnabled = true;
    break;
  case "DigitalOutputFirmata":
    digitalOutputEnabled = true;
    break;
  case "ServoFirmata":
    servoEnabled = true;
    break;
  case "FirmataScheduler":
    schedulerEnabled = true;
    break;
  }
}

/**
 * @private
 */
function processFeatureSelection(selectedFeatures) {
  var len = selectedFeatures.length;
  for (var i = 0; i < len; i++) {
    setEnabledFeatures(selectedFeatures[i]);
    var feature = allFeatures[selectedFeatures[i]];

    if (feature.reporting) {
      featuresWithReporting.push(feature);
    }
    if (feature.update) {
      featuresWithUpdate.push(feature)
    }
  }

  if (featuresWithReporting.length > 0) {
    reportingEnabled = true;
  }

  if (featuresWithUpdate.length > 0) {
    updateEnabled = true;
  }
}

/**
 * @private
 */
function createHeader() {
  var date = new Date();
  var header = "/*\n * " + filename + ".ino generated by FirmataBuilder\n";
  header += " * " + date.toString() + "\n */\n\n";
  return header;
}

/**
 * @private
 */
function createIncludes(selectedFeatures) {
  var includes = "#include <Firmata.h>\n\n";

  for (var i = 0, len = selectedFeatures.length; i < len; i++) {
    var feature = allFeatures[selectedFeatures[i]];

    if (feature.systemDependencies) {
      for (var j = 0; j < feature.systemDependencies.length; j++) {
        d = feature.systemDependencies[j];
        // prevent duplicate includes
        if (!systemDependencies[d.className]) {
          includes += "#include <" + d.path + d.className + ".h>\n";
          systemDependencies[d.className] = true
        }
      }
    }

    includes += "#include <" + feature.path + feature.className + ".h>\n";
    includes += feature.className + " " + feature.instanceName + ";\n\n";
  };

  // always include FirmataExt
  includes += "#include <utility/FirmataExt.h>\n";
  includes += "FirmataExt firmataExt;\n\n";

  return includes;
}

/**
 * Dependencies that should be included after the initial set of included files.
 * @private
 */
function createPostDependencies() {
  var includes = "";
  if (analogOutputEnabled || servoEnabled) {
    includes += "#include <utility/AnalogWrite.h>\n\n";
  }
  if (reportingEnabled) {
    includes += "#include <utility/FirmataReporting.h>\n";
    includes += "FirmataReporting reporting;\n\n";
  }
  return includes;
}

/**
 * @private
 */
function createSystemResetCallbackFn() {
  var fn = "void systemResetCallback()\n";
  fn += "{\n";
  fn += "  for (byte i = 0; i < TOTAL_PINS; i++) {\n";
  fn += "    if (IS_PIN_ANALOG(i)) {\n";

  if (analogInputEnabled) {
    fn += "      Firmata.setPinMode(i, ANALOG);\n";
  }

  fn += "    } else if (IS_PIN_DIGITAL(i)) {\n";

  if (digitalOutputEnabled) {
    fn += "      Firmata.setPinMode(i, OUTPUT);\n";
  }

  fn += "    }\n";
  fn += "  }\n";

  fn += "  firmataExt.reset();\n";

  fn += "}\n\n";
  return fn;
}

/**
 * @private
 */
function createSetupFn(selectedFeatures) {
  var fn = "void setup()\n";
  fn += "{\n";

  fn += "  Firmata.setFirmwareVersion(FIRMATA_MAJOR_VERSION, FIRMATA_MINOR_VERSION);\n\n";

  if (analogOutputEnabled || servoEnabled) {
    fn += "  Firmata.attach(ANALOG_MESSAGE, analogWriteCallback);\n\n";
  }

  for (var i = 0, len = selectedFeatures.length; i < len; i++) {
    var feature = allFeatures[selectedFeatures[i]];
    fn += "  firmataExt.addFeature(" + feature.instanceName + ");\n";
  }

  if (reportingEnabled) {
    fn += "  firmataExt.addFeature(reporting);\n\n";
  }

  fn += "  Firmata.attach(SYSTEM_RESET, systemResetCallback);\n\n";

  if (connectionType.serial) {
    fn += "  Firmata.begin(" + connectionType.serial.baud + ");\n\n";
  }

  fn += "  systemResetCallback();\n";

  fn += "}\n\n";
  return fn;
}

/**
 * @private
 */
function createLoopFn() {
  var fn = "void loop()\n";
  fn += "{\n";

  if (digitalInputEnabled) {
    fn += "  digitalInput.report();\n\n";
  }

  fn += "  while(Firmata.available()) {\n";
  fn += "    Firmata.processInput();\n";

  if (schedulerEnabled) {
    fn += "    if (!Firmata.isParsingMessage()) {\n";
    fn += "      goto runtasks;\n";
    fn += "    }\n";
    fn += "  }\n"; // end while (if scheduler)
    fn += "  if (!Firmata.isParsingMessage()) {\n";
    fn += "runtasks: scheduler.runTasks();\n";
  }

  // if scheduler end if, else end while
  fn += "  }\n\n";

  if (reportingEnabled) {
    var numReporting = featuresWithReporting.length;
    fn += "  if (reporting.elapsed()) {\n";
    for (var i = 0; i < numReporting; i++) {
      fn += ("    " + featuresWithReporting[i].instanceName + ".report();\n");
    }
    fn += "  }\n\n";
  }

  if (updateEnabled) {
    var numUpdate = featuresWithUpdate.length
    for (var k = 0; k < numUpdate; k++) {
      fn += ("  " + featuresWithUpdate[k].instanceName + ".update();\n");
    }
  }

  fn += "}\n";
  return fn;
}

/**
 * @module builder
 * Given a set of Firmata features and options, generates text for an Arduino
 * .ino file.
 */
var builder = {
  /**
   * @param {Object} data User selected features and options
   * @return {String} The text for the .ino file
   */
  build: function(data) {
    var outputText = "";

    filename = data.filename;
    connectionType = data.connectionType || {serial: {baud: 57600}};

    processFeatureSelection(data.selectedFeatures);

    outputText += createHeader();
    outputText += createIncludes(data.selectedFeatures);
    outputText += createPostDependencies();
    outputText += createSystemResetCallbackFn();
    outputText += createSetupFn(data.selectedFeatures);
    outputText += createLoopFn();

    return outputText;
  }
};

module.exports = builder;
